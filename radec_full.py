#! /usr/bin/python

"""
Just a tiny bit of python code to take the
catalogs of SpIES AORs (generated by sextractor_batch.py
in /cos_pc19a_npr/SpIES/catalogs) and plot them up
along the Stripe... 

You will need:
  - SPITZER_I1_469_SpIES_cat.lis

TOFIX: This bit of baby code is working pretty well at the moment. 
"""

import matplotlib.pyplot as plt
import numpy as np
import aplpy
import atpy
import pyfits
from pylab import *
from astropy.coordinates import ICRS, Galactic
from astropy import units as u


cat_dir = '/cos_pc19a_npr/SpIES/catalogs/ch1/5sigma_cats/'

## READ IN DATA...
#f = open('SPITZER_I1_469_SpIES_cat.lis')  ## Ch1
f = open('SPITZER_I1_469_SpIES_5sigmacats.lis')  ## Ch1
#f = open('SpIES_Ch2_pbcds88.lis')        ## Ch2

## Define plot ranges at beginning, since used often later.
YRANGE = [-1.5,1.5]

#XRANGE = [-40., 45.]  # Don't know how to do wrap-around yet... :-(
#XRANGE = [330., 360.]  # The "first half"
#XRANGE = [0., 36.]     # The "second half

## Observed chunks...
#XRANGE = [350., 360.]  # 

## Unobserved chunks...
XRANGE = [331., 337.]   # "first', unobserved chunk..
#XRANGE = [337., 347.]   # "2nd', unobserved chunk..
#XRANGE = [344., 354.]   # "3rd', unobserved chunk..
#XRANGE = [354., 361.]   # "4th', unobserved chunk..
#XRANGE = [4., 15.]     # "5th', unobserved chunk..
#XRANGE = [30., 37.5]     # "6th', unobserved chunk..

## Observed chunks...
#XRANGE = [-1., 15.]  # 



## Define figure size and formatting
fig = plt.figure(1, figsize=(12,6))
fig.subplots_adjust(left=0.12, bottom=0.12, top=0.96, right=0.96)

## Simply plot X vs. Y as data points.
total_size_cat = 0 
for line in f:
    #print cat_dir+line
    cat_file = cat_dir+line
    data = pyfits.open(cat_file)
    tbdata = data[1].data

    size_cat = len(data[1].data)
    total_size_cat = total_size_cat + size_cat
    ra  = tbdata.ALPHA_J2000
    dec = tbdata.DELTA_J2000
    print mean(dec)
    plt.plot(ra, dec, 'o', ms=4, alpha=0.1, color='blue')
    data.close()

print total_size_cat
## Set plot ranges, axes ticks and axes labels.
plt.xlim(XRANGE)                 # Set x plot range.
plt.ylim(YRANGE)                 # Set y plot range.
plt.xticks(fontsize=16)          # Set ticks x axis.
plt.yticks(fontsize=16)          # Set ticks y axis.
plt.xlabel(r'R.A. (J2000)', fontsize=24)  # Set label x axis.
plt.ylabel(r'Decl. (J2000)', fontsize=24)  # Set label y axis.


"""
Okay, so now want to read-in some sort of data
file that has the coordinate and geometry info for
the 'pre-' and 'post-' (observed) AORs, and overlay
these as rectangles to the current coverage maps...
"""

# Let's just set a few things up first...
# IRAC Field of View is 5.2' x 5.2'
# (IRAC Instruments Handbook Sec 2.2.1) 

irac_side   = 312.0  # in arcsecs
step_size   = 280.0  # in arcsecs. It's this value that offsets the IRAC FOVs for our observations.
                     # both in the RA/column and Decl./row
half_step   = 140.0  # half a step-size...

AOR_rows    =  28.   
AOR_columns =   10.    # for SPIES-22634-a-1 and 22647-a-1, this is 5.

#AOR_height  = irac_side * AOR_rows
#AOR_width   = irac_side * AOR_columns
AOR_height  = step_size * AOR_rows
AOR_width   = step_size * AOR_columns

## Now, read in the AOR files, and take the RA and Decl centres...
## Have 3 choices here, (1) the "full" file, with a bit of a mix of columns;
## (2) and the has Been Observered...
## (3) the "To Be" Observed file...
## Even more than that, the "To Be" file has two potential extremes...
 
#r = np.genfromtxt('../../../AORs/the_fullAOR_details_file.dat', dtype=None, skip_header=1, names='name,ra_hms,dec_hms', usecols=(0, 1, 2))
#r = np.genfromtxt('../../../AORs/the_fullAOR_details_file_BeenObserved.dat', dtype=None, skip_header=1, names='name,ra_hms,dec_hms, pa_from_hdr, pa_from_spot', usecols=(0, 1, 2, 5, 6))
#r = np.genfromtxt('../../../AORs/the_fullAOR_details_file_2BObserved.dat', dtype=None, skip_header=1, names='name, ra_hms, dec_hms, pa_spot_min, pa_spot_max', usecols=(0, 1, 2,10, 11))
r = np.genfromtxt('the_fullAOR_details_file_2BObserved.dat', dtype=None, skip_header=1, names='name, ra_hms, dec_hms, pa_spot_min, pa_spot_max', usecols=(0, 1, 2,10, 11))

aor_center = [ICRS(r['ra_hms'][i] + ' ' + r['dec_hms'][i]) for i in range(len(r))]
#print 'aor_center[0].ra.deg', aor_center[0].ra.deg

## Key line(s) for setting up the PAs...
## For the already observed 88 AORs
#pa_angle   = r['pa_from_hdr']
#pa_angle   = r['pa_from_spot']
# For the To Be observed 66 AORs
#pa_angle   = r['pa_spot_min']
pa_angle   = r['pa_spot_max']

#print 'pa_angle ', pa_angle 


## Here aor_center_ra _dec is a "Type:       list"
aor_center_ra  =[aor_center[i].ra.deg  for i in range(len(r))]
aor_center_dec =[aor_center[i].dec.deg for i in range(len(r))]

##  Now make aor_center_ra into an "Type:       ndarray"
aor_center_ra  = np.array(aor_center_ra)
aor_center_dec = np.array(aor_center_dec)

#print 'aor_center_ra (in deg)'
## (.5) * (280" /3600.)
aor_center_ra = aor_center_ra + 0.0388889
print 'aor_center_ra OFFSET BEING APPLIED!!!'
print
print 'aor_center_ra'
print aor_center_ra
print
print 'aor_center_dec'
print aor_center_dec


print
print
print 'aor PA Angle'
#print pa_angle
print

## Top right...
AOR_RA_corner1  =  aor_center_ra + ((0.5*AOR_width)/3600.)    
AOR_DEC_corner1 = aor_center_dec + ((0.5*AOR_height)/3600.)

## Top left...
AOR_RA_corner2  =  aor_center_ra - ((0.5*AOR_width)/3600.)
AOR_DEC_corner2 = aor_center_dec + ((0.5*AOR_height)/3600.)

## bottom left...
AOR_RA_corner3  =  aor_center_ra - ((0.5*AOR_width)/3600.)
AOR_DEC_corner3 = aor_center_dec - ((0.5*AOR_height)/3600.)

## bottom right
AOR_RA_corner4  =  aor_center_ra + ((0.5*AOR_width)/3600.)
AOR_DEC_corner4 = aor_center_dec - ((0.5*AOR_height)/3600.)

#print 'AOR_RA_corner1 ', AOR_RA_corner1

## Making a rectanlge...
corner_ra  = [AOR_RA_corner1,   AOR_RA_corner2,  AOR_RA_corner3,  AOR_RA_corner4,  AOR_RA_corner1]
corner_dec = [AOR_DEC_corner1, AOR_DEC_corner2, AOR_DEC_corner3, AOR_DEC_corner4, AOR_DEC_corner1]

## Making the (kinda obvious!) realization that the AOR rotation will
## NOT be from (R.A., Decl.) = (0.0, 0.0), but is from the centre of
## the AOR itself...
vector_corner_ra  =  corner_ra -  aor_center_ra
vector_corner_dec = corner_dec - aor_center_dec

## Note that Spot reports a Roll Angle -
## degrees east of north of the projected Spitzer to-sun vector.
## (and in the Observed AOR header, e.g.,
## PA      =            -103.5631 / [deg] Position angle of axis 2 (E of N) 
angle = (90.+pa_angle)/(180./pi)   

##  Rotation Matrix: 
##    R = [[cos theta, sin theta], 
##         [-sin theta, cos theta]]
## =>
##   x_prime =  x*cos(theta) + y*sin(theta)
##   y_prime = -x*sin(theta) + y*cos(theta)

## vector_corner_ra is a  Type:       ndarray
## angle            is a  Type:       ndarray
corner_ra_prime  = [(      (vector_corner_ra[0:,i] * math.cos(angle[i])) + (vector_corner_dec[0:,i] * math.sin(angle[i]))) + aor_center_ra[i]  for i in range(len(r))]
corner_dec_prime = [(((-1.)*vector_corner_ra[0:,i] * math.sin(angle[i])) + (vector_corner_dec[0:,i] * math.cos(angle[i]))) + aor_center_dec[i] for i in range(len(r))]

## And now magically OVERPLOT!!
#plt.plot(corner_ra_prime, corner_dec_prime, 'o', ms=4, linewidth=2, alpha=1., color='red')
[plt.plot(corner_ra_prime[i], corner_dec_prime[i], '-', ms=4, linewidth=2, alpha=1., color='green') for i in range(len(r))]


#plt.savefig('ra_dec_overlay_temp.png') # Save png file.
plt.savefig('ra_dec_temp.png') # Save png file.

#plt.close








